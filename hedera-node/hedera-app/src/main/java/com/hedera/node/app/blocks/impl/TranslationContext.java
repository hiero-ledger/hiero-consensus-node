// SPDX-License-Identifier: Apache-2.0
package com.hedera.node.app.blocks.impl;

import static com.hedera.node.app.hapi.utils.CommonUtils.noThrowSha384HashOf;

import com.hedera.hapi.block.stream.output.TransactionOutput;
import com.hedera.hapi.block.stream.output.TransactionResult;
import com.hedera.hapi.node.base.HederaFunctionality;
import com.hedera.hapi.node.base.Transaction;
import com.hedera.hapi.node.base.TransactionID;
import com.hedera.hapi.node.transaction.ExchangeRateSet;
import com.hedera.hapi.node.transaction.SignedTransaction;
import com.hedera.hapi.node.transaction.TransactionRecord;
import com.hedera.pbj.runtime.io.buffer.Bytes;

/**
 * Base interface for objects that have extra context needed to easily translate a {@link TransactionResult} and,
 * optionally, a {@link TransactionOutput} into a {@link TransactionRecord} to be returned from a query.
 */
public interface TranslationContext {
    /**
     * Returns the memo of the transaction.
     * @return the memo
     */
    String memo();

    /**
     * The exchange rate set to include in the receipt for this transaction.
     * @return an exchange rate set applicable to the transaction receipt.
     */
    ExchangeRateSet transactionExchangeRates();

    /**
     * Returns the transaction ID of the transaction.
     * @return the transaction ID
     */
    TransactionID txnId();

    /**
     * Returns the transaction itself.
     *
     * @return the transaction
     */
    SignedTransaction signedTx();

    /**
     * Returns the functionality of the transaction.
     * @return the functionality
     */
    HederaFunctionality functionality();

    /**
     * Returns the serialized {@link SignedTransaction}, if known.
     * <p>
     * Will always be non-null if the tx originated through HAPI. In this case, either:
     * <ol>
     *     <li>The deserialized message will have {@code useLegacyTransactionHashAlgorithm = false} and the
     *     serialization will be identical to the bytes the HAPI client placed in
     *     {@link Transaction#signedTransactionBytes()}; or,</li>
     *     <li>The deserialized message will have {@code useLegacyTransactionHashAlgorithm = true} and the
     *     serialization will be what results from using ascending field order for the {@link SignedTransaction}
     *     constructed from the submitted {@link Transaction}'s {@code sigMap} and {@code bodyBytes}. (In this case,
     *     the only byte-for-byte guarantee relative to the HAPI submission is that the
     *     {@link SignedTransaction#bodyBytes()} are identical to what the HAPI client put in
     *     {@link Transaction#bodyBytes()}; hence signatures can still be verified.)
     * </ol>
     * @return the serialized signed transaction
     */
    Bytes serializedSignedTx();

    /**
     * Returns the hash of the transaction as it should appear in the legacy record stream, or be served from
     * existing APIs that look up transactions by hash.
     * @return the transaction hash
     */
    default Bytes transactionHash() {
        final var signedTx = signedTx();
        if (signedTx.useSerializedTxMessageHashAlgorithm()) {
            final var tx = Transaction.newBuilder()
                    .bodyBytes(signedTx.bodyBytes())
                    .sigMap(signedTx.sigMap())
                    .build();
            final var bytes = Transaction.PROTOBUF.toBytes(tx);
            return Bytes.wrap(noThrowSha384HashOf(bytes.toByteArray()));
        } else {
            // Normal path, dealing with a SignedTransaction constructed from a HAPI Transaction
            // with non-deprecated fields or generated by the network as a synthetic transaction
            var bytes = serializedSignedTx();
            if (bytes == null) {
                bytes = SignedTransaction.PROTOBUF.toBytes(signedTx);
            }
            return Bytes.wrap(noThrowSha384HashOf(bytes.toByteArray()));
        }
    }
}
