/**
 * # Block Proof
 * A proof for the block streamed from a consensus node.
 *
 * ### Keywords
 * The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
 * "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
 * document are to be interpreted as described in
 * [RFC2119](https://www.ietf.org/rfc/rfc2119) and clarified in
 * [RFC8174](https://www.ietf.org/rfc/rfc8174).
 */
syntax = "proto3";

package com.hedera.hapi.block.stream;

// SPDX-License-Identifier: Apache-2.0
option java_package = "com.hedera.hapi.block.stream.protoc";
// <<<pbj.java_package = "com.hedera.hapi.block.stream">>> This comment is special code for setting PBJ Compiler java package
option java_multiple_files = true;

import "block/stream/record_file_item.proto";
import "block/stream/chain_of_trust_proof.proto";
import "block/stream/state_proof.proto";

/**
 * A cryptographic proof for the "Block Merkle Tree".
 *
 * This message SHALL offer a proof for the "Block Merkle Tree".
 * The information in the "Block Merkle Tree" SHALL be used to validate the
 * full content of the most recent block, and, with chained validation,
 * all prior blocks.
 *
 * ### Block Merkle Tree
 * The Block Hash of any block is a merkle root hash comprised of a binary
 * merkle tree, as described below.
 *
 * #### Computing the hash
 * The process for computing a block hash is somewhat complex, and involves
 * creating a "virtual" merkle tree to obtain the root merkle hash of
 * that virtual tree.<br/>
 * The merkle tree SHALL have the following structure:
 * - The merkle tree SHALL be structured as a binary tree.
 * - The merkle tree root SHALL have a "left-most" node containing the
 *   block's beginning timestamp.
 * - The merkle tree root SHALL have a "right-most" subtree comprised of 16
 *   leaves and associated internal nodes.
 * - The first four "levels" of the "right-most" subtree SHALL be internal
 *   nodes, comprising 15 in total.
 * - The fifth level of the "right-most" subtree SHALL be comprised of 16
 *   components (detailed below).<br/>
 * The "right-most" subtree's 16 components SHALL be, in order (from left
 * to right):
 * 1. A leaf containing the previous block's root hash.
 * 2. A sub-tree of "incrementally-collapsed" block hashes, ranging from
 *    the genesis block to the block immediately preceding the current
 *    block number, strictly ordered by block number.
 * 3. A leaf containing the hash of the state merkle tree at the start of
 *    the block.
 * 4. The root of a merkle tree composed of all consensus header items
 *    in the block. Leaf nodes in this subtree SHALL be ordered in the
 *    same order that the block items are encountered in the stream.
 * 5. The root of a merkle tree composed of all input items in the block.
 *    Input items SHALL be transactions, system transactions, and events.
 *    Leaf nodes in this subtree SHALL be ordered in the same order that
 *    the block items are encountered in the stream.
 * 6. The root of a merkle tree composed of all output items in the
 *    block. Output items SHALL be transaction result or transaction
 *    output items. Leaf nodes in this subtree SHALL be ordered in the
 *    same order that the block items are encountered in the stream.
 * 7. The root of a merkle tree composed of all state changes in the
 *    block. State change items SHALL be transaction result or
 *    transaction output items. Leaf nodes in this subtree SHALL be
 *    ordered in the same order that the block items are encountered
 *    in the stream.
 * 8. The root of a merkle tree composed of all trace data items in the
 *    block. Trace data items SHALL be transaction result or transaction
 *    output items. Leaf nodes in this subtree SHALL be ordered in the
 *    same order that the block items are encountered in the stream.
 * 9-16: Empty leaf nodes reserved for future use.<br/>
 * For the "right-most" subtree's internal nodes:
 * - Level four's internal nodes SHALL be the parents of the (ordered)
 *   16 leaves described above.
 * - Level three's internal nodes SHALL be the parents of level four's
 *   (ordered) internal nodes.
 * - Level two's internal nodes SHALL be the parents of level three's
 *   (ordered) internal nodes.
 * - Level one's internal node SHALL be the (single) parent of level two's
 *   (ordered) internal nodes.
 * The block hash SHALL be the hash calculated for the root of this merkle
 *   tree.
 * - The hash algorithm used SHALL be the algorithm specified in the
 *   corresponding block header.
 *
 * The term "incrementally collapsed" above is significant, and changes how
 * the tree hash is computed. Internal nodes are produced only when necessary
 * to add additional leaf nodes, and leaves may be at slightly different locations
 * in the tree if there are not enough nodes "to the right" to complete the full
 * tree. The specifics of this algorithm are published in detailed system
 * documentation.
 */
message BlockProof {
    /** // TODO Do we really need this field?
     * The block this proof secures.<br/>
     * We provide this because a proof for a future block can be used to prove
     * the state of the ledger at that block and the blocks before it.<br/>
     * <p>
     * This value SHOULD match the block number of the current block,
     * under normal operation.
     */
    uint64 block = 1;

    /**
     * The proof contents verifying the block's merkle root hash.<br/>
     * This is a `oneof` field that MAY contain one several types of
     * proofs.
     */
    oneof proof {
        /**
         * A TSS signature over the block's merkle root hash.<br/>
         * This signature SHALL be produced by a threshold signature scheme
         * that allows multiple nodes to contribute partial signatures that
         * can be aggregated into a single signature. This field MUST be
         * used when the current block is signed directly by the consensus
         * nodes with a TSS signature; otherwise it MUST be empty.
         */
        TssSignedBlockProof signed_block_proof = 2;

        /**
         * A proof of the block merkle tree's contents. This proof SHALL
         * contain the information necessary to validate the previous block's
         * hash, along with any information necessary to validate the current
         * block's hash.
         * <p>
         * Of necessity, the state proof MUST contain a set of hash values,
         * along with ordering information, that allows for reconstruction of the
         * block's hash. This list of hash values form the set of sibling hash values
         * needed to correctly reconstruct the parent hash, and all hash values
         * "above" that hash in the merkle tree.
         * <p>
         * A Block proof can be constructed by combining the sibling hashes for
         * a previous block hash and sibling hashes for each entry "above" that
         * node in the merkle tree of a block proof that incorporates that previous
         * block hash. This form of block proof may be used to prove a chain of
         * blocks when one or more older blocks is missing the original block
         * proof that signed the block's merkle root directly.
         * <p>
         * Such a list MUST be ordered from the sibling of the node that contains
         * this block's root node hash, and continues up the merkle tree to the
         * root hash of the signed block proof.
         * <p>
         * If this block proof has a "direct" signature, then any associated list
         * of siblings MUST be empty.<br/>
         * If said list is not empty, then this block proof MUST be verified by
         * first constructing the "block" merkle tree and computing the root hash
         * of that tree, then combining that hash with the values in this list,
         * paying attention to the first/second sibling ordering, until the root
         * merkle hash is produced from the last pair of sibling hashes. That
         * "secondary" root hash MUST then be verified using the value of
         * `block_signature`.
         */
        StateProof block_state_proof = 3;

        /**
         * A proof consisting of RSA signatures from consensus nodes.<br/>
         * This proof type exists for backward compatibility with blocks that
         * wrap historical record files.<br/>
         * This field MUST be set when the block wraps a record file signed by
         * individual RSA signatures from consensus nodes; otherwise it MUST be
         * empty.
         */
        SignedRecordFileProof signed_record_file_proof = 4;

        /**
         * If there is not yet a SNARK proving the chain of trust from ledger id to
         * the hinTS verification key, an aggregation of Schnorr signatures on
         * the concatenation of the ledger id and genesis hinTS verification key
         * that serve as witnesses for the SNARK prover algorithm.
         */
        AggregatedNodeSignatures aggregated_node_signatures = 5;
    }
}

/**
 * A hash of a "sibling" to an entry in a Merkle tree.
 *
 * When constructing a binary merkle tree, each internal node is a hash
 * constructed from the hash of two "descendant" nodes. Those two nodes
 * are "siblings" and the order (first, second) in which the two hash values
 * are combined affects the parent hash.<br/>
 * This may be used to reconstruct a portion of a merkle tree starting from
 * a node of interest up to the root of the tree.
 */
message MerkleSiblingHash {
    /**
     * A flag for the position of this sibling.
     * <p>
     * If this is set then this sibling MUST be the first hash in the pair of
     * sibling hashes of a binary merkle tree.<br/>
     * If this is unset, then this sibling MUST be the second hash in the pair
     * of sibling hashes of a binary merkle tree.
     */
    bool is_first = 1;

    /**
     * A byte array of a sibling hash.<br/>
     * This is the hash for the sibling at this point in the merkle tree.
     * <p>
     * The algorithm for this hash SHALL match the algorithm for the block that
     * contains this sibling.<br/>
     * This SHALL contain the raw (e.g.) 384 bits (48 bytes) of the hash value.
     */
    bytes sibling_hash = 2;
}

/**
 * A proof containing RSA signatures from consensus nodes for a block that was
 * originally recorded in the record file format. It contains a list of
 * signatures over the record file hash. How to compute the record file hash
 * depends on the record file format version it was originally created with. To
 * verify a block with a SignedRecordFileProof, the record file hash needs to be
 * computed according to the record file format version and then verified with
 * the signatures in this proof and the public keys of the consensus nodes at
 * the point the record file was created. The public keys can be obtained form
 * the network address book from a trusted source. See `RecordFileItem`
 * documentation for description of how to compute the record file hash.
 */
message SignedRecordFileProof {
  /**
   * The record file format version, this dictates how the hash that is signed
   * is computed. Valid versions are 2, 5 and 6.
   */
  uint32 version = 1;

  /**
   * A collection of RSA signatures from consensus nodes.<br/>
   * These signatures validate the record file hash.
   */
  repeated RecordFileSignature record_file_signatures = 2;
}

/**
 * A signature by a node on the record file hash. See `RecordFileItem`
 * documentation for description of how to compute the record file hash.
 */
message RecordFileSignature {
  /**
   * A single RSA signature in DER-encoded X.509 certificate format.<br/>
   * This is the RSA signature by the node's private RSA key on the record
   * file hash.
   */
  bytes signatures_bytes = 1;

  /**
   * A unique node identifier.<br/>
   * This is the node id of the consensus node that created this signature.
   */
  int32 node_id = 2;
}
