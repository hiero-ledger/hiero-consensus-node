/**
 * # Block Proof
 * A proof for the block streamed from a consensus node.
 *
 * ### Keywords
 * The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
 * "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
 * document are to be interpreted as described in
 * [RFC2119](https://www.ietf.org/rfc/rfc2119) and clarified in
 * [RFC8174](https://www.ietf.org/rfc/rfc8174).
 */
syntax = "proto3";

package com.hedera.hapi.block.stream;

// SPDX-License-Identifier: Apache-2.0
option java_package = "com.hedera.hapi.block.stream.protoc";
// <<<pbj.java_package = "com.hedera.hapi.block.stream">>> This comment is special code for setting PBJ Compiler java package
option java_multiple_files = true;

import "block/stream/record_file_item.proto";
import "block/stream/chain_of_trust_proof.proto";
import "block/stream/state_proof.proto";

/**
 * A cryptographic proof for the "Block Merkle Tree".
 *
 * This message SHALL offer a proof for the "Block Merkle Tree".
 * The information in the "Block Merkle Tree" SHALL be used to validate the
 * full content of the most recent block, and, with chained validation,
 * all prior blocks.
 *
 * ### Block Merkle Tree
 * The Block Hash of any block is a merkle root hash comprised of a binary
 * merkle tree, as described below.
 *
 * #### Computing the hash
 * The process for computing a block hash is somewhat complex, and involves
 * creating a "virtual" merkle tree to obtain the root merkle hash of
 * that virtual tree.<br/>
 * The merkle tree SHALL have the following structure:
 * - The merkle tree SHALL be structured as a binary tree.
 * - The merkle tree root SHALL have a "left-most" node containing the
 *   block's beginning timestamp.
 * - The merkle tree root SHALL have a "right-most" subtree comprised of 16
 *   leaves and associated internal nodes.
 * - The first four "levels" of the "right-most" subtree SHALL be internal
 *   nodes, comprising 15 in total.
 * - The fifth level of the "right-most" subtree SHALL be comprised of 16
 *   components (detailed below).<br/>
 * The "right-most" subtree's 16 components SHALL be, in order (from left
 * to right):
 * 1. A leaf containing the previous block's root hash.
 * 2. A sub-tree of "incrementally-collapsed" block hashes, ranging from
 *    the genesis block to the block immediately preceding the current
 *    block number, strictly ordered by block number.
 * 3. A leaf containing the hash of the state merkle tree at the start of
 *    the block.
 * 4. The root of a merkle tree composed of all consensus header items
 *    in the block. Leaf nodes in this subtree SHALL be ordered in the
 *    same order that the block items are encountered in the stream.
 * 5. The root of a merkle tree composed of all input items in the block.
 *    Input items SHALL be transactions, system transactions, and events.
 *    Leaf nodes in this subtree SHALL be ordered in the same order that
 *    the block items are encountered in the stream.
 * 6. The root of a merkle tree composed of all output items in the
 *    block. Output items SHALL be transaction result or transaction
 *    output items. Leaf nodes in this subtree SHALL be ordered in the
 *    same order that the block items are encountered in the stream.
 * 7. The root of a merkle tree composed of all state changes in the
 *    block. State change items SHALL be transaction result or
 *    transaction output items. Leaf nodes in this subtree SHALL be
 *    ordered in the same order that the block items are encountered
 *    in the stream.
 * 8. The root of a merkle tree composed of all trace data items in the
 *    block. Trace data items SHALL be transaction result or transaction
 *    output items. Leaf nodes in this subtree SHALL be ordered in the
 *    same order that the block items are encountered in the stream.
 * 9-16: Empty leaf nodes reserved for future use.<br/>
 * For the "right-most" subtree's internal nodes:
 * - Level four's internal nodes SHALL be the parents of the (ordered)
 *   16 leaves described above.
 * - Level three's internal nodes SHALL be the parents of level four's
 *   (ordered) internal nodes.
 * - Level two's internal nodes SHALL be the parents of level three's
 *   (ordered) internal nodes.
 * - Level one's internal node SHALL be the (single) parent of level two's
 *   (ordered) internal nodes.
 * The block hash SHALL be the hash calculated for the root of this merkle
 *   tree.
 * - The hash algorithm used SHALL be the algorithm specified in the
 *   corresponding block header.
 */
message BlockProof {
    /**
     * The block this proof secures.<br/>
     * We provide this because a proof for a future block can be used to prove
     * the state of the ledger at that block and the blocks before it.<br/>
     * <p>
     * This value SHOULD match the block number of the current block,
     * under normal operation.
     */
    uint64 block = 1;

    /**
     * A set of hash values along with ordering information.<br/>
     * This list of hash values form the set of sibling hash values needed to
     * correctly reconstruct the parent hash, and all hash values "above" that
     * hash in the merkle tree.
     * <p>
     * A Block proof can be constructed by combining the sibling hashes for
     * a previous block hash and sibling hashes for each entry "above" that
     * node in the merkle tree of a block proof that incorporates that previous
     * block hash. This form of block proof may be used to prove a chain of
     * blocks when one or more older blocks is missing the original block
     * proof that signed the block's merkle root directly.
     * <p>
     * This list MUST be ordered from the sibling of the node that contains
     * this block's root node hash, and continues up the merkle tree to the
     * root hash of the signed block proof.
     * <p>
     * If this block proof has a "direct" signature, then this list MUST be
     * empty.<br/>
     * If this list is not empty, then this block proof MUST be verified by
     * first constructing the "block" merkle tree and computing the root hash
     * of that tree, then combining that hash with the values in this list,
     * paying attention to the first/second sibling ordering, until the root
     * merkle hash is produced from the last pair of sibling hashes. That
     * "secondary" root hash MUST then be verified using the value of
     * `block_signature`.
     */
    repeated MerkleSiblingHash sibling_hashes = 2;

    /**
     * The hinTS key that this signature verifies under; a stream consumer should
     * only use this key after first checking the chain of trust proof.
     */
    bytes verification_key = 3;

    /**
     * Proof the hinTS verification key is in the chain of trust extending
     * from the network's ledger id.
     */
    ChainOfTrustProof verification_key_proof = 4;

    /**
     * The proof contents verifying the block's merkle root hash.<br/>
     * This is a `oneof` field that MAY contain one several types of
     * proofs.
     */
    oneof proof {
        /**
         * A TSS signature over the block's merkle root hash.<br/>
         * This signature SHALL be produced by a threshold signature scheme
         * that allows multiple nodes to contribute partial signatures that
         * can be aggregated into a single signature. This field MUST be
         * used when the current block is signed directly by the consensus
         * nodes with a TSS signature; otherwise it MUST be empty.
         */
        TssSignedBlockProof signed_block_proof = 5;
        /**
         * A proof of the block merkle tree's contents. This proof SHALL
         * contain the information necessary to validate the previous block's
         * hash, along with any information necessary to validate the current
         * block's hash.
         */
        StateProof block_state_proof = 6;
        /**
         * A proof consisting of RSA signatures from consensus nodes.<br/>
         * This proof type exists for backward compatibility with blocks that
         * wrap historical record files.<br/>
         * This field MUST be set when the block wraps a record file signed by
         * individual RSA signatures from consensus nodes; otherwise it MUST be
         * empty.
         */
        SignedRecordFileProof signed_record_file_proof = 7;
    }
}

/**
 * A hash of a "sibling" to an entry in a Merkle tree.
 *
 * When constructing a binary merkle tree, each internal node is a hash
 * constructed from the hash of two "descendant" nodes. Those two nodes
 * are "siblings" and the order (first, second) in which the two hash values
 * are combined affects the parent hash.<br/>
 * This may be used to reconstruct a portion of a merkle tree starting from
 * a node of interest up to the root of the tree.
 */
message MerkleSiblingHash {
    /**
     * A flag for the position of this sibling.
     * <p>
     * If this is set then this sibling MUST be the first hash in the pair of
     * sibling hashes of a binary merkle tree.<br/>
     * If this is unset, then this sibling MUST be the second hash in the pair
     * of sibling hashes of a binary merkle tree.
     */
    bool is_first = 1;

    /**
     * A byte array of a sibling hash.<br/>
     * This is the hash for the sibling at this point in the merkle tree.
     * <p>
     * The algorithm for this hash SHALL match the algorithm for the block that
     * contains this sibling.<br/>
     * This SHALL contain the raw (e.g.) 384 bits (48 bytes) of the hash value.
     */
    bytes sibling_hash = 2;
}
