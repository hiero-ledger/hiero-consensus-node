syntax = "proto3";

package proto;

/*-
 * ‌
 * Hedera Network Services Protobuf
 * ​
 * Copyright (C) 2018 - 2022 Hedera Hashgraph, LLC
 * ​
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ‍
 */

import "basic_types.proto";
import "google/protobuf/wrappers.proto";

option java_package = "com.hederahashgraph.api.proto.java";
// <<<pbj.java_package = "com.hedera.hapi.node.hooks">>> This comment is special code for setting PBJ Compiler java package
option java_multiple_files = true;

/***
 * The Hiero extension points that accept a hook.
 */
enum HookExtensionPoint {
  /**
   * Used to customize an account's allowances during a CryptoTransfer transaction.
   */
  ACCOUNT_ALLOWANCE_HOOK = 0;
}

/**
 * Specifies the installation of a new hook at a specific id for the given owner.
 */
message HookInstallation {
  /**
   * The id of the hook's installer.
   */
  HookInstallerId installer_id = 1;

  /**
   * The hook install details.
   */
  HookInstall install = 2;

  /**
   * The index of the hook the new installation should be previous
   * to in the owner's doubly-linked list of hooks.
   */
  uint64 next_hook_index = 3;
}

/***
 * How to install a hook.
 */
message HookInstall {
  /**
   * The extension point for the hook.
   */
  HookExtensionPoint extension_point = 1;

  /**
   * The entity index to install the hook at.
   */
  uint64 index = 2;

  /**
   * The hook implementation.
   */
  oneof hook {
    /**
     * A hook programmed in EVM bytecode that does not require access to state
     * or interactions with external contracts.
     */
    PureEvmHook pure_evm_hook = 3;
    /**
     * A hook programmed in EVM bytecode that may access state or interact with
     * external contracts.
     */
    LambdaEvmHook lambda_evm_hook = 4;
  }

  /**
   * If set, a key that that can be used to remove or replace the hook; or (if
   * applicable, as with a lambda EVM hook) perform transactions that customize
   * the hook.
   */
  proto.Key admin_key = 5;

  /**
   * The charging specification for the hook.
   */
  HookChargingSpec charging_spec = 6;
}

/**
 * Specifies how a hook's execution costs are charged.
 */
message HookChargingSpec {
  /**
   * The charging specification.
   */
  oneof charging_spec {
    /**
     * The default charging pattern for a hook, which is to charge the caller.
     */
    CallerPays caller_pays = 1;
    /**
     * A charging pattern for a hook where the caller is charged only if the
     * hook fails.
     */
    CallerPaysOnFailure caller_pays_on_failure = 2;
  }
}

/**
 * A placeholder signifying the default charging pattern for a hook, which is
 * to charge the caller of the transaction that triggers the hook the costs of
 * executing the hook.
 */
message CallerPays {
}

/**
 * Specifies a charging pattern for a hook where the caller of the transaction
 * that triggers the hook is charged the costs of executing the hook only if
 * the hook fails. When the hook succeeds, the costs are charged to the
 * specified payer account.
 */
message CallerPaysOnFailure {
  /**
   * The account ID of the payer that is charged for the hook's execution when
   * the hook succeeds.
   */
  proto.AccountID hook_payer_id = 1;
}

/**
 * Definition of a lambda EVM hook.
 */
message PureEvmHook {
  /**
   * The specification for the hook.
   */
  EvmHookSpec spec = 1;
}

/**
 * Definition of a lambda EVM hook.
 */
message LambdaEvmHook {
  /**
   * The specification for the hook.
   */
  EvmHookSpec spec = 1;

  /**
   * Initial storage contents for the lambda, if any.
   */
  repeated LambdaStorageSlot storage_slots = 2;
}

/**
 * Shared specifications for an EVM hook. May be used for any extension point.
 */
message EvmHookSpec {
  /**
   * The source of the EVM bytecode for the hook.
   */
  oneof bytecode_source {
    /**
     * The id of a contract that implements the extension point API with EVM bytecode.
     */
    ContractID contract_id = 1;
  }

  /**
   * If present, the default gas limit to use when executing the EVM hook.
   */
  google.protobuf.UInt64Value default_gas_limit = 2;
}

/**
 * A slot in the storage of a lambda EVM hook.
 */
message LambdaStorageSlot {
  /**
   * The 32-byte key of the slot; leading zeros may be omitted.
   */
  bytes key = 1;

  /**
   * If the slot is present and non-zero, the 32-byte value of the slot;
   * leaving this field empty or setting it to binary zeros in an update
   * removes the slot.
   */
  bytes value = 2;
}