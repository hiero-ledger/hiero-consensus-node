// SPDX-License-Identifier: Apache-2.0
package org.hiero.consensus.otter.docker.app;

import com.google.protobuf.Empty;
import com.hedera.hapi.platform.state.NodeId;
import com.hedera.hapi.platform.state.PlatformState;
import edu.umd.cs.findbugs.annotations.NonNull;
import edu.umd.cs.findbugs.annotations.Nullable;
import io.grpc.Status;
import io.grpc.StatusRuntimeException;
import io.grpc.stub.StreamObserver;
import java.util.Objects;
import java.util.concurrent.ExecutorService;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.hiero.consensus.otter.docker.app.platform.ConsensusNodeManager;
import org.hiero.otter.fixtures.KeysAndCertsConverter;
import org.hiero.otter.fixtures.ProtobufConverter;
import org.hiero.otter.fixtures.container.proto.EventMessage;
import org.hiero.otter.fixtures.container.proto.InitRequest;
import org.hiero.otter.fixtures.container.proto.KillImmediatelyRequest;
import org.hiero.otter.fixtures.container.proto.LogEntry;
import org.hiero.otter.fixtures.container.proto.StartRequest;
import org.hiero.otter.fixtures.container.proto.SyntheticBottleneckRequest;
import org.hiero.otter.fixtures.container.proto.TestControlGrpc;
import org.hiero.otter.fixtures.container.proto.TransactionRequest;
import org.hiero.otter.fixtures.container.proto.TransactionRequestAnswer;
import org.hiero.otter.fixtures.logging.internal.InMemoryAppender;
import org.hiero.otter.fixtures.result.SubscriberAction;

/**
 * gRPC service implementation for managing communication between the test framework and the platform.
 * <p>
 * This service handles incoming messages to create and start the {@link ConsensusNodeManager} or submit transactions to
 * the platform. It also dispatches outgoing messages such as {@link PlatformState} changes or {@link LogEntry}s
 * generated by the platform via {@link OutboundDispatcher}.
 */
public final class DockerManager extends TestControlGrpc.TestControlImplBase {

    /** Logger */
    private static final Logger LOGGER = LogManager.getLogger(DockerManager.class);

    /** Executor service for handling the dispatched messages */
    private final ExecutorService executor;

    /** The ID of the node that this instance represents */
    private NodeId selfId;

    /** Manages the consensus nodes and platform lifecycle */
    @Nullable
    private ConsensusNodeManager nodeManager;

    /** Handles outgoing messages, may get called from different threads/callbacks */
    private volatile OutboundDispatcher dispatcher;

    /**
     * Constructs a DockerManager instance with the specified executor service.
     *
     * @param executor The executor service used for asynchronous operations.
     * @throws NullPointerException if the executor is null.
     */
    public DockerManager(@NonNull final ExecutorService executor) {
        this.executor = Objects.requireNonNull(executor, "executor cannot be null");
    }

    @Override
    public synchronized void init(
            @NonNull final InitRequest request, @NonNull final StreamObserver<Empty> responseObserver) {
        this.selfId = ProtobufConverter.toPbj(request.getSelfId());
        responseObserver.onNext(Empty.getDefaultInstance());
        responseObserver.onCompleted();
    }

    /**
     * Starts the communication channel with the platform using the provided {@link StartRequest}.
     * <p>
     * This method initializes the {@link ConsensusNodeManager} and sets up listeners for platform events. Results are
     * sent back to the test framework via the {@link StreamObserver}.
     *
     * @param request The request containing details required to construct the platform.
     * @param responseObserver The observer used to send messages back to the test framework.
     * @throws StatusRuntimeException if the platform is already started, or if the request contains invalid arguments.
     */
    @Override
    public synchronized void start(
            @NonNull final StartRequest request, @NonNull final StreamObserver<EventMessage> responseObserver) {
        // before starting the consensus node, the container must be initialized which sets the selfId
        if (selfId == null) {
            responseObserver.onError(Status.FAILED_PRECONDITION
                    .withDescription("DockerApp not initialized yet")
                    .asRuntimeException());
            return;
        }
        if (nodeManager != null) {
            responseObserver.onError(Status.ALREADY_EXISTS.asRuntimeException());
            return;
        }

        if (isInvalidRequest(request, responseObserver)) {
            return;
        }

        try {
            nodeManager = new ConsensusNodeManager(
                    selfId,
                    ProtobufConverter.toPbj(request.getVersion()),
                    ProtobufConverter.toPbj(request.getRoster()),
                    KeysAndCertsConverter.fromProto(request.getKeysAndCerts()),
                    request.getOverriddenPropertiesMap());

            dispatcher = new OutboundDispatcher(executor, responseObserver);

            // Capture the dispatcher in a final variable so the lambda remains valid
            final OutboundDispatcher currentDispatcher = dispatcher;

            nodeManager.registerPlatformStatusChangeListener(
                    notification -> dispatcher.enqueue(EventMessageFactory.fromPlatformStatusChange(notification)));

            nodeManager.registerConsensusRoundListener(
                    rounds -> dispatcher.enqueue(EventMessageFactory.fromConsensusRounds(rounds)));

            InMemoryAppender.subscribe(log -> {
                dispatcher.enqueue(EventMessageFactory.fromStructuredLog(log));
                return currentDispatcher.isCancelled() ? SubscriberAction.UNSUBSCRIBE : SubscriberAction.CONTINUE;
            });

            nodeManager.start();
        } catch (final Exception e) {
            LOGGER.error("Unexpected error while starting grpc server", e);
            if (dispatcher != null) {
                dispatcher.shutdown();
            }
            responseObserver.onError(Status.INTERNAL.withCause(e).asRuntimeException());
        }
    }

    /**
     * Checks if the provided {@link StartRequest} is invalid and sends an error response if necessary.
     * <p>
     * This method validates the fields of the {@link StartRequest}. If any of the conditions are not met, an
     * appropriate error is sent to the {@link StreamObserver}.
     *
     * @param request The {@link StartRequest} containing the details for starting the platform.
     * @param responseObserver The observer used to send error messages back to the test framework.
     * @return {@code true} if the request is invalid; {@code false} otherwise.
     */
    private static boolean isInvalidRequest(
            final StartRequest request, final StreamObserver<EventMessage> responseObserver) {
        if (!request.hasVersion()) {
            responseObserver.onError(Status.INVALID_ARGUMENT
                    .withDescription("version has to be specified")
                    .asRuntimeException());
            return true;
        }
        if (!request.hasRoster()) {
            responseObserver.onError(Status.INVALID_ARGUMENT
                    .withDescription("roster has to be specified")
                    .asRuntimeException());
            return true;
        }
        return false;
    }

    /**
     * Submits a transaction to the platform.
     * <p>
     * This method sends the transaction payload to the platform for processing.
     *
     * @param request The transaction request containing the payload.
     * @param responseObserver The observer used to confirm transaction submission.
     * @throws StatusRuntimeException if the platform is not started or if an internal error occurs.
     */
    @Override
    public synchronized void submitTransaction(
            @NonNull final TransactionRequest request,
            @NonNull final StreamObserver<TransactionRequestAnswer> responseObserver) {
        if (nodeManager == null) {
            sendNodeNotInitializeError(responseObserver);
            return;
        }

        try {
            final boolean result =
                    nodeManager.submitTransaction(request.getPayload().toByteArray());
            responseObserver.onNext(
                    TransactionRequestAnswer.newBuilder().setResult(result).build());
            responseObserver.onCompleted();
        } catch (final Exception e) {
            responseObserver.onError(Status.INTERNAL.withCause(e).asRuntimeException());
        }
    }

    /**
     * Updates the synthetic bottleneck settings for the platform.
     * <p>
     * This method allows the test framework to control the synthetic bottleneck behavior of the platform.
     *
     * @param request The request containing the sleep duration per round.
     * @param responseObserver The observer used to confirm the update.
     */
    @Override
    public synchronized void syntheticBottleneckUpdate(
            @NonNull final SyntheticBottleneckRequest request, @NonNull final StreamObserver<Empty> responseObserver) {
        if (nodeManager == null) {
            sendNodeNotInitializeError(responseObserver);
            return;
        }
        nodeManager.updateSyntheticBottleneck(request.getSleepMillisPerRound());
        responseObserver.onNext(Empty.getDefaultInstance());
        responseObserver.onCompleted();
    }

    private void sendNodeNotInitializeError(@NonNull final StreamObserver<?> responseObserver) {
        responseObserver.onError(Status.FAILED_PRECONDITION
                .withDescription("Application not started yet")
                .asRuntimeException());
    }

    /**
     * Immediately terminates the platform. The container and dispatcher are left intact to allow data to be gathered
     * for verification.
     *
     * @param request The request to terminate the platform.
     * @param responseObserver The observer used to confirm termination.
     * @throws RuntimeException if the termination process is interrupted.
     */
    @Override
    public synchronized void killImmediately(
            @NonNull final KillImmediatelyRequest request, @NonNull final StreamObserver<Empty> responseObserver) {
        try {
            if (nodeManager != null) {
                nodeManager.destroy();
                nodeManager = null;
            }
            if (dispatcher != null) {
                dispatcher.shutdown();
            }

            responseObserver.onNext(Empty.getDefaultInstance());
            responseObserver.onCompleted();
        } catch (final InterruptedException ie) {
            throw new RuntimeException(ie);
        }
    }
}
